---
title: Schema
description: Define document structure with schemas, types, validation, virtuals, and methods
---

# Schema

Schemas define the structure and validation rules for your documents. Mondoo supports both Mongoose-style and `$` API schema definitions.

## Defining Schemas

### Mongoose-Style Schema

```typescript
import { Schema, Types } from 'mondoo'

const userSchema = new Schema({
  // Simple type shorthand
  name: String,
  email: String,

  // Object with options
  age: { type: Number, min: 0, max: 150 },

  // Required fields
  username: { type: String, required: true },

  // Defaults
  role: { type: String, default: 'user' },
  createdAt: { type: Date, default: Date.now },

  // Enums
  status: { type: String, enum: ['active', 'inactive', 'pending'] },

  // References
  organization: { type: 'ObjectId', ref: 'Organization' },

  // Arrays
  tags: [String],
  posts: [{ type: 'ObjectId', ref: 'Post' }],

  // Nested objects
  address: {
    street: String,
    city: String,
    zipCode: String,
    country: { type: String, default: 'USA' }
  }
})
```

### $ API Schema (TypeScript-First)

```typescript
import { $ } from 'mondoo'

const userSchema = $.schema({
  name: $.string().required(),
  email: $.string().email().required(),
  age: $.number().min(0).max(150),
  username: $.string().required(),
  role: $.enum(['admin', 'user', 'guest']).default('user'),
  status: $.enum(['active', 'inactive', 'pending']),
  organization: $.objectId().ref('Organization'),
  tags: $.array($.string()),
  posts: $.array($.objectId().ref('Post')),
  address: $.object({
    street: $.string(),
    city: $.string(),
    zipCode: $.string(),
    country: $.string().default('USA')
  })
})
```

## Schema Options

Pass options as the second argument to the Schema constructor:

```typescript
const userSchema = new Schema({
  name: String,
  email: String
}, {
  // Automatic timestamps
  timestamps: true,  // adds createdAt and updatedAt

  // Custom timestamp field names
  timestamps: { createdAt: 'created', updatedAt: 'updated' },

  // Version key (__v)
  versionKey: true,     // default: true
  versionKey: '__ver',  // custom field name
  versionKey: false,    // disable

  // Strict mode
  strict: true,    // default: ignore fields not in schema
  strict: 'throw', // throw error on unknown fields
  strict: false,   // allow unknown fields

  // Collection name override
  collection: 'users',

  // Discriminator key for inheritance
  discriminatorKey: '__type',

  // ID options
  _id: true,  // default: add _id field
  id: true,   // default: add id virtual (string version)

  // toJSON/toObject options
  toJSON: {
    virtuals: true,
    getters: true,
    transform: (doc, ret) => {
      delete ret.__v
      return ret
    }
  },

  toObject: {
    virtuals: true
  }
})
```

## Supported Types

### Primitive Types

| Type | Mongoose | $ API |
|------|----------|-------|
| String | `String` | `$.string()` |
| Number | `Number` | `$.number()` |
| Boolean | `Boolean` | `$.boolean()` |
| Date | `Date` | `$.date()` |
| BigInt | `BigInt` | `$.bigint()` |

### Special Types

| Type | Mongoose | $ API |
|------|----------|-------|
| ObjectId | `'ObjectId'` | `$.objectId()` |
| Buffer | `'Buffer'` | `$.buffer()` |
| Mixed | `'Mixed'` | `$.mixed()` / `$.any()` |

### Complex Types

| Type | Mongoose | $ API |
|------|----------|-------|
| Array | `[String]` | `$.array($.string())` |
| Nested Object | `{ field: String }` | `$.object({ field: $.string() })` |
| Map | `Map` | `$.map($.string())` |
| Enum | `{ enum: [...] }` | `$.enum([...])` |
| Literal | - | `$.literal('value')` |

## Validation

### Built-in Validators

```typescript
const schema = new Schema({
  // String validators
  email: {
    type: String,
    match: /^[^\s@]+@[^\s@]+\.[^\s@]+$/,
    minLength: 5,
    maxLength: 255
  },

  // Number validators
  age: {
    type: Number,
    min: 0,
    max: 150
  },

  // Enum validator
  role: {
    type: String,
    enum: ['admin', 'user', 'guest']
  },

  // Required validator
  username: { type: String, required: true }
})
```

### Custom Validators

```typescript
const schema = new Schema({
  // Sync validator
  username: {
    type: String,
    validate: (value) => value.length >= 3
  },

  // Async validator
  email: {
    type: String,
    validate: async (value) => {
      const exists = await checkEmailExists(value)
      return !exists
    }
  },

  // RegExp validator
  phone: {
    type: String,
    validate: /^\d{10}$/
  }
})
```

### $ API Validators

```typescript
const schema = $.schema({
  // String validators
  email: $.string().email().required(),
  url: $.string().url(),
  uuid: $.string().uuid(),
  pattern: $.string().regex(/^[A-Z]+$/),

  // String length
  name: $.string().min(2).max(100),
  code: $.string().length(6),

  // Number validators
  age: $.number().min(0).max(150),
  count: $.number().int().positive(),
  temperature: $.number().finite(),

  // Array validators
  tags: $.array($.string()).min(1).max(10),
  items: $.array($.number()).nonempty(),

  // Custom validator
  custom: $.string().validate((v) => v.startsWith('prefix_'))
})
```

## Virtuals

Virtuals are computed properties that are not persisted to the database:

```typescript
const userSchema = new Schema({
  firstName: String,
  lastName: String,
  email: String
})

// Define a virtual getter
userSchema.virtual('fullName')
  .get(function() {
    return `${this.firstName} ${this.lastName}`
  })
  .set(function(value) {
    const parts = value.split(' ')
    this.firstName = parts[0]
    this.lastName = parts.slice(1).join(' ')
  })

// Virtual with populate (for reverse lookups)
userSchema.virtual('posts', {
  ref: 'Post',
  localField: '_id',
  foreignField: 'author',
  justOne: false  // return array
})
```

Using virtuals:

```typescript
const user = await User.findById(id)
console.log(user.fullName)  // "John Doe"

user.fullName = 'Jane Smith'
console.log(user.firstName) // "Jane"
console.log(user.lastName)  // "Smith"

// Populate virtual
const userWithPosts = await User.findById(id).populate('posts')
```

## Instance Methods

Add custom methods to document instances:

```typescript
const userSchema = new Schema({
  password: String,
  email: String
})

// Single method
userSchema.method('comparePassword', async function(candidate: string) {
  return await bcrypt.compare(candidate, this.password)
})

// Multiple methods
userSchema.method({
  async sendEmail(subject: string, body: string) {
    await sendEmail(this.email, subject, body)
  },

  getProfile() {
    return {
      email: this.email,
      // Don't include password
    }
  }
})
```

Using methods:

```typescript
const user = await User.findById(id)
const isValid = await user.comparePassword('secret123')
await user.sendEmail('Welcome!', 'Thanks for joining.')
```

## Static Methods

Add custom methods to the model class:

```typescript
const userSchema = new Schema({
  email: String,
  role: String
})

// Single static
userSchema.static('findAdmins', function() {
  return this.find({ role: 'admin' })
})

// Multiple statics
userSchema.static({
  async findByEmail(email: string) {
    return this.findOne({ email })
  },

  async createAdmin(data: Partial<User>) {
    return this.create({ ...data, role: 'admin' })
  }
})
```

Using statics:

```typescript
const admins = await User.findAdmins()
const user = await User.findByEmail('john@example.com')
const newAdmin = await User.createAdmin({ email: 'admin@example.com' })
```

## Indexes

Define indexes on your schema:

```typescript
const userSchema = new Schema({
  email: { type: String, unique: true },  // Field-level index
  username: { type: String, index: true },
  createdAt: Date
})

// Compound index
userSchema.index({ email: 1, createdAt: -1 })

// Text index
userSchema.index({ name: 'text', bio: 'text' })

// Geospatial index
userSchema.index({ location: '2dsphere' })

// Index with options
userSchema.index(
  { email: 1 },
  { unique: true, sparse: true, background: true }
)
```

## Plugins

Extend schema functionality with plugins:

```typescript
// Define a plugin
function timestampPlugin(schema: Schema, options?: { createdAt?: string; updatedAt?: string }) {
  const createdAt = options?.createdAt || 'createdAt'
  const updatedAt = options?.updatedAt || 'updatedAt'

  schema.add({
    [createdAt]: { type: Date, default: Date.now },
    [updatedAt]: Date
  })

  schema.pre('save', function(next) {
    this[updatedAt] = new Date()
    next()
  })
}

// Apply the plugin
userSchema.plugin(timestampPlugin)
userSchema.plugin(timestampPlugin, { createdAt: 'created', updatedAt: 'modified' })
```

## Schema Inspection

```typescript
// Get a path's SchemaType
const emailType = schema.path('email')

// Check path type
schema.pathType('email')     // 'real'
schema.pathType('fullName')  // 'virtual'
schema.pathType('address.city') // 'nested'

// Get required paths
const required = schema.requiredPaths()

// Iterate over all paths
schema.eachPath((path, type) => {
  console.log(`${path}: ${type.constructor.name}`)
})

// Clone schema
const clonedSchema = schema.clone()

// Get schema options
const options = schema.options
const collection = schema.get('collection')
```
