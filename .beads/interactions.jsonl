{"id":"mondoose-0y5","title":"Implement population system for references","description":"Population system implementing Mongoose API:\n\n## Basic Population\n- query.populate(path, [select])\n- Resolve ObjectId refs to full documents\n- Support for array of refs\n\n## Population Options\n- path: field to populate\n- select: projection for populated docs\n- match: filter criteria\n- model: override ref model\n- options: sort, limit, skip\n\n## Advanced Features\n- Nested population (populate within populate)\n- Virtual population (reverse lookups)\n- refPath - dynamic model references\n- Circular reference handling\n\n## ğŸš€ CAPNWEB map() OPTIMIZATION\n\nPopulation is the KILLER use case for capnweb's map() method:\n\n```typescript\n// Instead of N+1 queries, use map() for single round-trip:\nconst usersWithPosts = await User.find({}).map(user =\u003e [\n  user,\n  Post.find({ authorId: user._id })  // Recorded, not executed!\n])\n\n// Nested population in one trip:\nconst populated = await docs.map(doc =\u003e [\n  doc,\n  ...doc.refs.map(ref =\u003e RefModel.findById(ref))\n])\n```\n\nThis makes mondoose population DRAMATICALLY faster than Mongoose.\n\n## Integration Points\n- Works with lean()\n- Works with find/findOne/findById\n- Batch queries via map() (one query per ref model)\n- Query deduplication built into capnweb\n\nEstimated: ~1,000 LOC","status":"closed","priority":1,"issue_type":"feature","created_at":"2026-01-04T16:55:27.602572-06:00","updated_at":"2026-01-04T18:44:12.779531-06:00","closed_at":"2026-01-04T18:44:12.779531-06:00","close_reason":"Population system for references fully implemented"}
{"id":"mondoose-agf","title":"Implement Query builder with chainable API","description":"Query builder class implementing Mongoose API:\n\n## Query State\n- _filter, _projection, _options\n- _populate, _lean\n- Model reference\n\n## Chainable Filter Methods\n- where(path).equals(val)\n- gt/gte/lt/lte/in/nin/ne\n- exists, regex, mod, type\n- elemMatch, size, all\n\n## Chainable Options\n- select(fields) - projection\n- sort(order)\n- limit(n) / skip(n)\n- lean(bool) - return POJOs\n- populate(path, select, options)\n- session(clientSession)\n\n## Execution\n- exec() â†’ Promise\n- then/catch - thenable interface\n- cursor() â†’ QueryCursor\n- Lazy execution (doesn't run until awaited)\n\n## ğŸš€ CAPNWEB PROMISE PIPELINING\n\nQueries return RpcPromise, enabling chaining without round trips:\n\n```typescript\n// All THREE operations in ONE round trip!\nconst user = User.findById(id)           // RpcPromise\nconst posts = Post.find({ author: user._id })  // Uses promise ref\nconst comments = await Comment.find({ author: user._id })\n// Only the final await triggers network\n```\n\n### map() for Bulk Operations\n```typescript\n// Update all matching docs\nconst updated = await User.find({ trial: true }).map(user =\u003e\n  User.updateOne({ _id: user._id }, { $set: { expired: true }})\n)\n```\n\n## Middleware Integration\n- Run pre('find') / post('find') hooks\n- Query context in middleware\n\n**Blocked by:** mondodb-b7am (positional operators), mondodb-i0lh (query operators)\n\nEstimated: ~1,200 LOC","status":"closed","priority":1,"issue_type":"feature","created_at":"2026-01-04T16:55:14.313357-06:00","updated_at":"2026-01-04T18:44:01.952108-06:00","closed_at":"2026-01-04T18:44:01.952108-06:00","close_reason":"Query builder with chainable API fully implemented"}
{"id":"mondoose-b9f","title":"Implement Document class with change tracking","description":"Core Document class implementing Mongoose API:\n\n## Document State\n- _doc: actual data storage\n- $__: internal state (activePaths, modifiedPaths, saveError)\n- isNew: boolean flag for new documents\n- $isDeleted: deletion tracking\n\n## Change Tracking\n- Proxy-based change detection\n- markModified(path) - force path as modified\n- isModified(path?) - check if modified\n- modifiedPaths() - get all modified paths\n- directModifiedPaths() - get direct modifications only\n\n## Core Methods\n- save() - with validation and hooks\n- validate() - run validators\n- toObject(options) - convert to POJO\n- toJSON(options) - JSON serialization\n- get(path) / set(path, value) - nested access\n\n## Population Support\n- populate(path) - load references\n- populated(path) - get populated ObjectId\n- depopulate(path) - restore ObjectId\n\n## Session Support\n- $session() - get/set transaction session\n\n## ğŸš€ CAPNWEB map() FOR NESTED SAVES\n\n```typescript\n// Save document with all modified subdocs in ONE trip\nconst saved = await doc.save().map(parent =\u003e [\n  parent,\n  ...parent.$__.modifiedSubdocs.map(sub =\u003e sub.save())\n])\n```\n\n## ğŸ¯ TYPESCRIPT-FIRST DESIGN\n\nDocument class is generic over inferred schema type:\n\n```typescript\n// Document\u003cT\u003e where T is inferred from schema\nconst user: Document\u003cUser\u003e = new User({ name: 'Ada' })\n\nuser.name  // string (typed\\!)\nuser.age   // number | undefined (optional in schema)\nuser.save() // Promise\u003cDocument\u003cUser\u003e\u003e\n\n// Methods are typed from schema.method()\nuser.fullName()  // Return type inferred from method definition\n```\n\nEstimated: ~1,800 LOC","status":"closed","priority":0,"issue_type":"feature","created_at":"2026-01-04T16:55:01.447962-06:00","updated_at":"2026-01-04T18:43:26.102662-06:00","closed_at":"2026-01-04T18:43:26.102662-06:00","close_reason":"Document class implemented with change tracking, dirty checking, save/validate"}
{"id":"mondoose-c7q","title":"Documentation in MDX (fumadocs convention)","description":"Create comprehensive documentation in .mdx files following fumadocs conventions.\n\n## Structure\n\n```\ndocs/\nâ”œâ”€â”€ index.mdx                 # Introduction \u0026 quick start\nâ”œâ”€â”€ getting-started/\nâ”‚   â”œâ”€â”€ installation.mdx\nâ”‚   â”œâ”€â”€ quick-start.mdx\nâ”‚   â””â”€â”€ migrating-from-mongoose.mdx\nâ”œâ”€â”€ guide/\nâ”‚   â”œâ”€â”€ schemas.mdx           # Schema definition (both APIs)\nâ”‚   â”œâ”€â”€ models.mdx\nâ”‚   â”œâ”€â”€ documents.mdx\nâ”‚   â”œâ”€â”€ queries.mdx\nâ”‚   â”œâ”€â”€ population.mdx\nâ”‚   â”œâ”€â”€ middleware.mdx\nâ”‚   â”œâ”€â”€ validation.mdx\nâ”‚   â”œâ”€â”€ typescript.mdx        # TypeScript-first patterns\nâ”‚   â””â”€â”€ cloudflare-workers.mdx\nâ”œâ”€â”€ api/\nâ”‚   â”œâ”€â”€ dollar-namespace.mdx  # $ API reference\nâ”‚   â”œâ”€â”€ schema.mdx\nâ”‚   â”œâ”€â”€ model.mdx\nâ”‚   â”œâ”€â”€ document.mdx\nâ”‚   â”œâ”€â”€ query.mdx\nâ”‚   â””â”€â”€ aggregate.mdx\nâ””â”€â”€ advanced/\n    â”œâ”€â”€ capnweb-pipelining.mdx  # Promise pipelining patterns\n    â”œâ”€â”€ map-method.mdx          # The magic map() for batching\n    â”œâ”€â”€ discriminators.mdx\n    â”œâ”€â”€ plugins.mdx\n    â””â”€â”€ transactions.mdx\n```\n\n## Key Sections\n\n### Quick Start\n- Installation\n- Basic schema definition (show BOTH APIs)\n- Creating models\n- CRUD operations\n\n### Migration Guide\n- Side-by-side Mongoose â†’ Mondoose\n- API compatibility notes\n- What's different (capnweb, $ namespace)\n\n### TypeScript Guide\n- $.infer\u003c\u003e usage\n- Type-safe queries\n- Population type transformation\n- Generic patterns\n\n### Cloudflare Workers Guide\n- env-based connection\n- Durable Objects architecture\n- Promise pipelining for performance\n\n## Conventions\n- Use fumadocs frontmatter\n- Include runnable code examples\n- Show both $ and Mongoose APIs where relevant\n- Highlight capnweb performance benefits","status":"closed","priority":1,"issue_type":"task","created_at":"2026-01-04T17:20:08.381828-06:00","updated_at":"2026-01-04T19:05:18.585553-06:00","closed_at":"2026-01-04T19:05:18.585553-06:00","close_reason":"9 MDX documentation files complete"}
{"id":"mondoose-cbj","title":"Implement Aggregate class wrapping mondodb aggregation","description":"Aggregate class implementing Mongoose API:\n\n## Pipeline Building\n- Chainable stage methods: addFields, count, facet, group, limit, lookup, match, project, sample, skip, sort, unwind, etc.\n- append(stage) - add raw stage\n- pipeline() - get current pipeline\n\n## Execution Options\n- allowDiskUse()\n- batchSize()\n- cursor()\n- explain()\n- hint()\n- session()\n\n## Execution\n- exec() â†’ Promise\n- then/catch - thenable interface\n- cursor() â†’ AggregationCursor\n\n## Middleware\n- Run pre('aggregate') / post('aggregate') hooks\n\n## Integration\n- Wraps mondodb's collection.aggregate()\n- Uses mondodb's aggregation translator (SQLite CTEs)\n\n**Blocked by mondodb aggregation stages (mondodb-bqmc, mondodb-e0dd)**\n\nEstimated: ~600 LOC","status":"closed","priority":2,"issue_type":"feature","created_at":"2026-01-04T16:55:42.248406-06:00","updated_at":"2026-01-04T18:53:13.437945-06:00","closed_at":"2026-01-04T18:53:13.437945-06:00","close_reason":"Aggregate class fully implemented with 76 tests - all pipeline stages, chainable API, cursor support"}
{"id":"mondoose-chq","title":"NPM package publish preparation","description":"Prepare mondoose for npm publication.\n\n## Package Setup\n\n### package.json\n```json\n{\n  \"name\": \"mondoose\",\n  \"version\": \"0.1.0\",\n  \"description\": \"Mongoose-compatible ODM for Cloudflare Durable Objects with TypeScript-first $ API\",\n  \"main\": \"dist/index.js\",\n  \"module\": \"dist/index.mjs\",\n  \"types\": \"dist/index.d.ts\",\n  \"exports\": {\n    \".\": {\n      \"import\": \"./dist/index.mjs\",\n      \"require\": \"./dist/index.js\",\n      \"types\": \"./dist/index.d.ts\"\n    }\n  },\n  \"files\": [\"dist\"],\n  \"keywords\": [\n    \"mongoose\", \"mongodb\", \"odm\", \"cloudflare\", \n    \"durable-objects\", \"workers\", \"typescript\", \"zod\"\n  ],\n  \"repository\": \"github:...\",\n  \"license\": \"MIT\",\n  \"peerDependencies\": {\n    \"mondodb\": \"^x.x.x\"\n  }\n}\n```\n\n### Build Configuration\n- tsup or unbuild for dual CJS/ESM\n- Generate .d.ts declarations\n- Source maps\n- Minification\n\n## README.md\n\n### Sections\n1. Hero/tagline\n2. Features (bullet points)\n3. Installation\n4. Quick start (both APIs)\n5. Why mondoose? (vs Mongoose)\n6. TypeScript-first design\n7. Capnweb performance benefits\n8. Documentation link\n9. Contributing\n10. License\n\n### Badges\n- npm version\n- TypeScript\n- License\n- Bundle size\n\n## Files to Create\n- [ ] README.md\n- [ ] LICENSE (MIT)\n- [ ] CHANGELOG.md\n- [ ] CONTRIBUTING.md\n- [ ] .npmignore\n- [ ] tsconfig.json (for declarations)\n- [ ] Build script configuration\n\n## Pre-publish Checklist\n- [ ] All tests passing\n- [ ] Types build correctly\n- [ ] Bundle size acceptable\n- [ ] README complete\n- [ ] CHANGELOG for v0.1.0\n- [ ] npm publish --dry-run succeeds","status":"closed","priority":1,"issue_type":"task","created_at":"2026-01-04T17:20:14.706803-06:00","updated_at":"2026-01-04T18:45:16.361608-06:00","closed_at":"2026-01-04T18:45:16.361608-06:00","close_reason":"Package.json configured, build passes, dist files generated (cjs, esm, dts)"}
{"id":"mondoose-d3n","title":"TypeScript-first schema design with Zod-like inference","description":"## Core Design Philosophy\n\nUnlike Mongoose where you define types AND schemas separately, mondoose infers types from schema definitions:\n\n```typescript\n// âŒ Mongoose: Duplicate definitions\ninterface IUser {\n  name: string\n  email?: string\n  age?: number\n}\nconst userSchema = new Schema\u003cIUser\u003e({\n  name: { type: String, required: true },\n  email: String,\n  age: Number\n})\n\n// âœ… Mondoose: Single source of truth\nconst userSchema = m.schema({\n  name: m.string().required(),\n  email: m.string().email(),\n  age: m.number().min(0)\n})\ntype User = m.infer\u003ctypeof userSchema\u003e\n// Automatically: { name: string; email?: string; age?: number }\n```\n\n## Type Builder API (Zod-inspired)\n\n### Primitives\n```typescript\nm.string()           // string | undefined\nm.string().required() // string (non-optional)\nm.number()\nm.boolean()\nm.date()\nm.objectId()\nm.buffer()\nm.bigint()\n```\n\n### Validators that affect types\n```typescript\nm.string().email()      // still string, but validated\nm.string().url()\nm.string().uuid()\nm.string().regex(/.../)\nm.string().min(1).max(100)\n\nm.number().int()        // number, but validated as integer\nm.number().positive()\nm.number().min(0).max(100)\n\nm.enum(['admin', 'user', 'guest'])  // 'admin' | 'user' | 'guest'\nm.literal('active')                  // 'active' (literal type)\n```\n\n### Complex types\n```typescript\nm.array(m.string())     // string[]\nm.array(m.objectId().ref('Post'))  // ObjectId[] with ref info\n\nm.object({              // Nested object\n  street: m.string(),\n  city: m.string().required()\n})\n\nm.map(m.number())       // Map\u003cstring, number\u003e\n\nm.union([m.string(), m.number()])  // string | number\nm.discriminatedUnion('type', [...]) // Tagged union\n```\n\n### References with type inference\n```typescript\nconst postSchema = m.schema({\n  title: m.string().required(),\n  author: m.objectId().ref('User')  // Ref\u003cUser\u003e\n})\n\n// When populated:\ntype PostPopulated = m.infer\u003ctypeof postSchema, { author: true }\u003e\n// { title: string; author: User }  // User type, not ObjectId\\!\n```\n\n## Implementation Strategy\n\n### SchemaType base class\n```typescript\nabstract class SchemaType\u003cT, Required extends boolean = false\u003e {\n  abstract _type: T\n  abstract _required: Required\n  \n  required(): SchemaType\u003cT, true\u003e { ... }\n  default(val: T | (() =\u003e T)): this { ... }\n  validate(fn: (v: T) =\u003e boolean): this { ... }\n}\n```\n\n### Inference magic\n```typescript\ntype Infer\u003cS extends Schema\u003e = {\n  [K in keyof S['shape']]: S['shape'][K] extends SchemaType\u003cinfer T, infer R\u003e\n    ? R extends true ? T : T | undefined\n    : never\n}\n```\n\n### Population type transformation\n```typescript\ntype PopulatedDoc\u003cT, Paths extends keyof T\u003e = {\n  [K in keyof T]: K extends Paths\n    ? T[K] extends Ref\u003cinfer M\u003e ? M : T[K]\n    : T[K]\n}\n```\n\n## Benefits\n1. **No duplication** - schema IS the type\n2. **Type-safe validators** - .email() only on strings\n3. **Inferred optionality** - required() affects TS optional\n4. **Ref type transformation** - populate() changes types\n5. **IDE autocomplete** - full IntelliSense from schema\n\n## Research References\n- Zod: https://github.com/colinhacks/zod\n- Drizzle ORM: https://orm.drizzle.team\n- Valibot: https://valibot.dev\n- TypeBox: https://github.com/sinclairzx81/typebox","status":"closed","priority":0,"issue_type":"feature","created_at":"2026-01-04T17:14:31.030354-06:00","updated_at":"2026-01-04T18:43:37.334059-06:00","closed_at":"2026-01-04T18:43:37.334059-06:00","close_reason":"TypeScript-first schema with Zod-like inference via $ namespace"}
{"id":"mondoose-ezz","title":"Implement Schema class with type definitions and validation","description":"Core Schema class implementing Mongoose API:\n\n## Schema Definition\n- Path definitions with SchemaTypes (String, Number, Boolean, Date, ObjectId, Array, Buffer, Mixed, Map, Decimal128, Subdocument)\n- Nested path resolution (user.address.city)\n- Schema options (strict, timestamps, versionKey, toJSON, toObject, autoIndex)\n\n## Validation\n- Built-in validators (required, min, max, enum, match, minLength, maxLength)\n- Custom validators with async support\n- ValidationError formatting matching Mongoose\n\n## Methods \u0026 Virtuals\n- schema.method() - instance methods\n- schema.static() - static methods  \n- schema.virtual() - virtual properties with getters/setters\n\n## Hooks Infrastructure\n- schema.pre() / schema.post()\n- Support for validate, save, remove, updateOne, deleteOne, find, findOne, aggregate\n\n## Plugins\n- schema.plugin(fn, options)\n- Global plugins via mongoose.plugin()\n\n## ğŸ¯ TYPESCRIPT-FIRST DESIGN (Zod-like inference)\n\nUnlike Mongoose where types are separate from schema, mondoose uses inference:\n\n```typescript\n// Schema definition IS the type definition\nconst userSchema = m.schema({\n  name: m.string().required(),\n  email: m.string().email(),\n  age: m.number().min(0).max(150),\n  role: m.enum(['admin', 'user', 'guest']),\n  profile: m.object({\n    bio: m.string(),\n    avatar: m.string().url()\n  }),\n  tags: m.array(m.string()),\n  createdAt: m.date().default(() =\u003e new Date())\n})\n\n// Type is INFERRED - no separate interface needed\\!\ntype User = m.infer\u003ctypeof userSchema\u003e\n// { name: string; email?: string; age?: number; role?: 'admin'|'user'|'guest'; ... }\n\nconst User = mondoose.model('User', userSchema)\n// User.create() is fully typed from schema\n```\n\n### Benefits over Mongoose\n- Single source of truth (no interface + schema duplication)\n- Validators create type constraints automatically\n- .required() affects optionality in type\n- .enum() creates union types\n- Nested objects infer nested types\n\n**Blocked by:** mondodb-wair (validation infrastructure)\n\nEstimated: ~2,500 LOC","status":"closed","priority":0,"issue_type":"feature","created_at":"2026-01-04T16:54:55.049086-06:00","updated_at":"2026-01-04T18:43:20.625122-06:00","closed_at":"2026-01-04T18:43:20.625122-06:00","close_reason":"Schema class fully implemented with type definitions, validation, virtuals, methods, statics"}
{"id":"mondoose-gq9","title":"Dual API: Mongoose compatibility + Zod-style $ namespace","description":"## Vision\n\nMondoose supports TWO schema APIs that compile to the same internal representation:\n\n1. **$.schema() API** - Zod-like, TypeScript-first (recommended for new projects)\n2. **new Schema() API** - Mongoose-compatible (for migrations)\n\n## The $ Namespace\n\n```typescript\nimport { $, Schema, model } from 'mondoose'\n\n// âœ¨ Zod-style API (TypeScript-first)\nconst userSchema = $.schema({\n  name: $.string().required(),\n  email: $.string().email(),\n  age: $.number().min(0).max(150),\n  role: $.enum(['admin', 'user', 'guest']),\n  posts: $.array($.objectId().ref('Post'))\n})\ntype User = $.infer\u003ctypeof userSchema\u003e\n\n// ğŸ”§ Mongoose-style API (migration-friendly)  \nconst legacySchema = new Schema({\n  name: { type: String, required: true },\n  email: { type: String, validate: /^.+@.+$/ },\n  age: { type: Number, min: 0, max: 150 },\n  role: { type: String, enum: ['admin', 'user', 'guest'] },\n  posts: [{ type: Schema.Types.ObjectId, ref: 'Post' }]\n})\n\n// Both work with model()!\nconst User = model('User', userSchema)\n```\n\n## Mix \u0026 Match (Migration Path)\n\n```typescript\n// Start with existing Mongoose schema\nconst legacySchema = new Schema({\n  name: { type: String, required: true },\n  email: String,\n})\n\n// Extend with $-style for new fields\nconst extendedSchema = legacySchema.add({\n  profile: $.object({\n    bio: $.string().max(500),\n    avatar: $.string().url()\n  }),\n  settings: $.map($.boolean())\n})\n\n// Type inference works on combined schema!\ntype User = $.infer\u003ctypeof extendedSchema\u003e\n```\n\n## $ Namespace Implementation\n\n```typescript\nexport const $ = {\n  // Primitives\n  string: () =\u003e new StringType(),\n  number: () =\u003e new NumberType(),\n  boolean: () =\u003e new BooleanType(),\n  date: () =\u003e new DateType(),\n  objectId: () =\u003e new ObjectIdType(),\n  buffer: () =\u003e new BufferType(),\n  bigint: () =\u003e new BigIntType(),\n  \n  // Complex types\n  array: \u003cT\u003e(item: SchemaType\u003cT\u003e) =\u003e new ArrayType(item),\n  object: \u003cT\u003e(shape: T) =\u003e new ObjectType(shape),\n  map: \u003cT\u003e(value: SchemaType\u003cT\u003e) =\u003e new MapType(value),\n  \n  // Unions \u0026 enums\n  enum: \u003cT extends readonly string[]\u003e(values: T) =\u003e new EnumType(values),\n  literal: \u003cT extends string | number | boolean\u003e(value: T) =\u003e new LiteralType(value),\n  union: \u003cT extends SchemaType[]\u003e(types: T) =\u003e new UnionType(types),\n  discriminatedUnion: \u003cK extends string, T\u003e(key: K, schemas: T) =\u003e new DiscriminatedUnionType(key, schemas),\n  \n  // Schema creation\n  schema: \u003cT extends SchemaShape\u003e(shape: T) =\u003e new Schema(shape),\n  \n  // Type inference (compile-time only)\n  infer: null as unknown,  // $.infer\u003ctypeof schema\u003e\n  input: null as unknown,  // $.input\u003ctypeof schema\u003e (before transforms)\n  output: null as unknown, // $.output\u003ctypeof schema\u003e (after transforms)\n  \n  // Utilities\n  mixed: () =\u003e new MixedType(),\n  any: () =\u003e new MixedType(),\n  unknown: () =\u003e new UnknownType(),\n  \n  // Refs with type\n  ref: \u003cM extends string\u003e(model: M) =\u003e new RefType(model),\n  \n  // Transforms\n  transform: \u003cI, O\u003e(schema: SchemaType\u003cI\u003e, fn: (v: I) =\u003e O) =\u003e new TransformType(schema, fn),\n  \n  // Coercion (like zod's z.coerce)\n  coerce: {\n    string: () =\u003e new CoercedStringType(),\n    number: () =\u003e new CoercedNumberType(),\n    boolean: () =\u003e new CoercedBooleanType(),\n    date: () =\u003e new CoercedDateType(),\n  }\n}\n```\n\n## API Mapping\n\n| Zod-style ($)                    | Mongoose-style             | Internal Type      |\n|----------------------------------|----------------------------|-------------------|\n| $.string()                       | { type: String }           | StringType        |\n| $.string().required()            | { type: String, required: true } | StringType(req) |\n| $.string().email()               | { type: String, validate: emailRegex } | StringType+validator |\n| $.number().min(0)                | { type: Number, min: 0 }   | NumberType+min    |\n| $.enum(['a','b'])                | { type: String, enum: ['a','b'] } | EnumType     |\n| $.array($.string())              | [String]                   | ArrayType         |\n| $.objectId().ref('User')         | { type: ObjectId, ref: 'User' } | RefType      |\n| $.object({ name: $.string() })   | { name: { type: String } } | ObjectType        |\n| $.map($.number())                | { type: Map, of: Number }  | MapType           |\n\n## Architecture\n\n```\nâ”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”\nâ”‚                     User-Facing APIs                     â”‚\nâ”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤\nâ”‚   $.schema() API     â”‚      new Schema() API            â”‚\nâ”‚   (Zod-like)         â”‚      (Mongoose-like)             â”‚\nâ””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜\n                           â”‚\n                           â–¼\nâ”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”\nâ”‚              Internal Schema Representation              â”‚\nâ”‚   SchemaType { type, validators, options, refs }        â”‚\nâ”‚   - Unified AST for both input formats                  â”‚\nâ”‚   - Type inference works from internal repr             â”‚\nâ””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜\n                           â”‚\n                           â–¼\nâ”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”\nâ”‚           Validation / Serialization / Query            â”‚\nâ””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜\n```\n\n## Benefits\n\n1. **Migration path** - Mongoose users can migrate incrementally\n2. **TypeScript-first** - New users get Zod-like inference\n3. **Mix \u0026 match** - Extend legacy schemas with new syntax\n4. **Single mental model** - Same underlying behavior\n5. **Best of both** - Mongoose ecosystem + Zod ergonomics\n\n## Why $ ?\n\n- Short (1 char)\n- Memorable\n- Doesn't conflict with `z` (Zod) or `m` (mongoose)\n- Valid JS identifier\n- Suggests 'schema' or 'structure'\n- jQuery-like familiarity","status":"closed","priority":0,"issue_type":"feature","created_at":"2026-01-04T17:18:37.337098-06:00","updated_at":"2026-01-04T18:43:42.760087-06:00","closed_at":"2026-01-04T18:43:42.760087-06:00","close_reason":"Dual API implemented: Mongoose compatibility + Zod-style $ namespace"}
{"id":"mondoose-jeh","title":"Implement Model class wrapping mondodb collection","description":"Core Model class implementing Mongoose API:\n\n## Static Properties\n- schema, collection, modelName, db\n- discriminators map\n\n## CRUD Operations (wrapping mondodb)\n- create(docs) - with validation\n- insertMany(docs, options)\n- find/findOne/findById â†’ Query\n- findByIdAndUpdate/findOneAndUpdate\n- findByIdAndDelete/findOneAndDelete\n- updateOne/updateMany\n- deleteOne/deleteMany\n- replaceOne\n- countDocuments/estimatedDocumentCount\n- distinct(field, filter)\n- aggregate(pipeline) â†’ Aggregate\n\n## Document Hydration\n- hydrate(doc) - create Document from plain object\n- Batch hydration for find results\n\n## Index Management\n- createIndexes()\n- ensureIndexes()\n- syncIndexes()\n\n## Discriminators\n- discriminator(name, schema) - create child model\n- Merged schema with discriminatorKey\n\n## ğŸš€ CAPNWEB map() PATTERNS\n\n### Cascade Operations\n```typescript\n// Delete with cascades in ONE round trip\nconst result = await User.findByIdAndDelete(id).map(user =\u003e [\n  user,\n  Post.deleteMany({ authorId: user._id }),\n  Comment.deleteMany({ authorId: user._id })\n])\n```\n\n### Bulk Hydration with Discriminators\n```typescript\n// Resolve correct model for each doc\nconst hydrated = await collection.find(filter).map(raw =\u003e [\n  raw,\n  getDiscriminatorModel(raw.__t)?.hydrate(raw) ?? this.hydrate(raw)\n])\n```\n\n### Index Sync\n```typescript\n// Compare schema vs DB indexes\nconst sync = await collection.listIndexes().map(dbIdx =\u003e [\n  dbIdx,\n  this.schema.matchingIndex(dbIdx)\n])\n```\n\nEstimated: ~1,500 LOC","status":"closed","priority":0,"issue_type":"feature","created_at":"2026-01-04T16:55:08.099413-06:00","updated_at":"2026-01-04T18:43:31.921975-06:00","closed_at":"2026-01-04T18:43:31.921975-06:00","close_reason":"Model class implemented wrapping collection with CRUD operations"}
{"id":"mondoose-qrn","title":"Port/adapt Mongoose test suite to Vitest","description":"Test infrastructure for mondoose:\n\n## Strategy Decision: Port to Vitest (not degit Mocha)\n\nMongoose uses Mocha + mongodb-memory-server with ~200+ test files. \nRecommendation: **Manual port to Vitest** because:\n1. mondoose has different internals than Mongoose\n2. Vitest is faster and has better DX\n3. mondodb already uses Vitest\n4. Cherry-pick test patterns, not copy wholesale\n\n## Test Categories to Port\n1. Schema definition tests (types, validators, options)\n2. Document lifecycle tests (create, save, update, delete)\n3. Query builder tests (all operators and chainable methods)\n4. Population tests (basic, nested, virtual)\n5. Middleware tests (pre/post hooks)\n6. Aggregation tests (pipeline stages)\n7. Transaction tests\n8. Discriminator tests\n9. Plugin tests\n\n## Test Infrastructure\n- Use mondodb's in-memory mode for testing\n- Vitest with --reporter=verbose\n- Coverage via c8/v8\n- Parallel test execution\n\n## Compatibility Tests\n- Run same test cases against real Mongoose + MongoDB\n- Ensure API parity\n\nEstimated: 2-3 weeks focused effort","status":"closed","priority":1,"issue_type":"task","created_at":"2026-01-04T16:55:49.448755-06:00","updated_at":"2026-01-04T18:44:54.471458-06:00","closed_at":"2026-01-04T18:44:54.471458-06:00","close_reason":"295 vitest tests covering all modules - schema, document, model, query, middleware, connection, types, $"}
{"id":"mondoose-s18","title":"TypeScript type definitions matching Mongoose","description":"Full TypeScript support matching Mongoose's type definitions:\n\n## Core Types\n- Schema\u003cT\u003e with path inference\n- Document\u003cT\u003e with method types\n- Model\u003cT\u003e with static types\n- Query\u003cT\u003e with chainable types\n\n## Type Inference\n- Infer document type from schema definition\n- Method return type inference\n- Virtual type inference\n- Population type transformations\n\n## Generic Patterns\n- HydratedDocument\u003cT\u003e\n- LeanDocument\u003cT\u003e\n- QueryWithHelpers\u003cT\u003e\n- InferSchemaType\u003cT\u003e\n\n## Discriminator Types\n- Union types for discriminated documents\n- Type narrowing by discriminator key\n\n## Reference: @types/mongoose\nMirror the DefinitelyTyped patterns for Mongoose\n\nEstimated: ~1,000 LOC of type definitions","status":"closed","priority":2,"issue_type":"task","created_at":"2026-01-04T16:55:55.689281-06:00","updated_at":"2026-01-04T18:44:59.696028-06:00","closed_at":"2026-01-04T18:44:59.696028-06:00","close_reason":"TypeScript types fully implemented in src/types with SchemaType, InferSchema, and all type inference"}
{"id":"mondoose-wjy","title":"Implement middleware/hooks system (pre/post)","description":"Middleware system implementing Mongoose hooks API:\n\n## Hook Types\n- Document: validate, save, remove, updateOne, deleteOne, init\n- Query: find, findOne, findOneAndUpdate, findOneAndDelete, updateOne, updateMany, deleteOne, deleteMany\n- Aggregate: aggregate\n- Model: insertMany\n\n## Pre Hooks\n- schema.pre(operation, [options], fn)\n- Must call next() or return Promise\n- Can throw to abort operation\n- Access to context via this\n\n## Post Hooks  \n- schema.post(operation, fn)\n- Receive result as parameter\n- Can modify result before returning\n- Error handling post hooks\n\n## Execution Order\n- Pre-validate â†’ Post-validate â†’ Pre-save â†’ Post-save\n- Parallel vs serial execution\n- Error propagation\n\n## Options\n- { document: true, query: false } - distinguish middleware types\n- Multiple hooks per operation (chain)\n\n## ğŸš€ CAPNWEB map() FOR HOOKS\n\n### Post-hooks that fetch additional data\n```typescript\n// Post-find hook that enriches results\nschema.post('find', async function(docs) {\n  return docs.map(doc =\u003e [\n    doc,\n    AuditLog.create({ action: 'read', docId: doc._id })\n  ])\n})\n```\n\n### Cascade middleware\n```typescript\n// Pre-remove hook with cascades\nschema.pre('remove', async function() {\n  await this.constructor.find({ parentId: this._id }).map(child =\u003e\n    child.remove()  // Recursive cascade\n  )\n})\n```\n\nEstimated: ~800 LOC","status":"closed","priority":1,"issue_type":"feature","created_at":"2026-01-04T16:55:20.915488-06:00","updated_at":"2026-01-04T18:44:07.397207-06:00","closed_at":"2026-01-04T18:44:07.397207-06:00","close_reason":"Middleware/hooks system with pre/post hooks implemented"}
{"id":"mondoose-ylg","title":"Implement Connection adapter for mondodb/capnweb","description":"Connection management implementing Mongoose API but for Cloudflare Workers:\n\n## Connection Class\n- readyState: 0|1|2|3 (disconnected, connected, connecting, disconnecting)\n- models: Map\u003cstring, Model\u003e\n- db: mondodb Database reference\n\n## Cloudflare-Specific Patterns\n- createMondoose(env) - factory from Worker env\n- Persistent WebSocket via capnweb (NOT stateless HTTP!)\n- Promise pipelining for reduced latency\n- Session state maintained across calls\n\n## Model Registration\n- connection.model(name, schema) - register/get model\n- connection.models - map of registered models\n- connection.modelNames() - list model names\n\n## Session Support\n- connection.startSession() â†’ ClientSession\n- Transaction support via mondodb\n\n## Events (EventEmitter)\n- connected, disconnected, error, reconnected\n\n## Caching Strategy\n- Schema compilation cached\n- Model instances cached per env\n- WeakMap for env â†’ models mapping\n\n**Key insight: capnweb provides persistent connections, not stateless**\n\nEstimated: ~500 LOC","status":"closed","priority":1,"issue_type":"feature","created_at":"2026-01-04T16:55:35.569527-06:00","updated_at":"2026-01-04T18:44:18.340062-06:00","closed_at":"2026-01-04T18:44:18.340062-06:00","close_reason":"Connection adapter for mondodb/capnweb implemented"}
